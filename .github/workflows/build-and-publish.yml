name: Build and Publish Electron App

# This workflow builds the Electron app and publishes installers to the public repository

on:
  push:
    tags:
      - 'v*.*.*'  # Only run on version tags
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag name (e.g., v1.0.24)'
        required: true
        default: 'v1.0.24'
      publish_to_public:
        description: 'Publish to public repository'
        required: false
        default: 'true'
        type: choice
        options:
        - 'true'
        - 'false'

jobs:
  build-and-publish:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]
        include:
          - os: macos-latest
            name: macOS
            artifact_path: release/*.{dmg,zip}
          - os: ubuntu-latest
            name: Linux
            artifact_path: |
              release/*.AppImage
              release/*.deb
          - os: windows-latest
            name: Windows
            artifact_path: release/*.{exe,msi}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          ref: ${{ github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'

      - name: Install OS-specific dependencies (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          npm install --global --production windows-build-tools
          npm install --global node-gyp
        shell: bash

      - name: Set up Python (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Windows dependencies for canvas (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          choco install -y python3
          choco install -y gtk-runtime
          choco install -y libjpeg-turbo
        shell: bash

      - name: Install dependencies
        run: |
          npm ci
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            npm rebuild canvas --update-binary
          fi
        shell: bash

      - name: Build and Publish ${{ matrix.name }}
        run: |
          # Determine platform flag
          if [ "${{ matrix.os }}" = "macos-latest" ]; then
            PLATFORM_FLAG="--mac"
          elif [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            PLATFORM_FLAG="--linux"
          elif [ "${{ matrix.os }}" = "windows-latest" ]; then
            PLATFORM_FLAG="--win"
          fi
          
          npm run electron:build -- $PLATFORM_FLAG --publish always
          echo "Build completed for ${{ matrix.name }}. Checking for release creation..."
          sleep 30  # Wait for release to be created
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Verify release creation
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "Checking for release with tag: $TAG_NAME"
          curl -s -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG_NAME" | jq -r '.id, .tag_name, .draft'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Upload ${{ matrix.name }} artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-installers
          path: ${{ matrix.artifact_path }}

  copy-to-public-repo:
    needs: build-and-publish
    runs-on: ubuntu-latest
    if: github.event.inputs.publish_to_public != 'false'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Wait for all builds to complete
        run: |
          echo "Waiting for all builds to complete and releases to be created..."
          sleep 120  # Wait for 2 minutes to ensure all releases are created

      - name: Get release information
        id: get_release
        run: |
          # Extract tag name from github.ref or use input tag_name
          if [[ "${{ github.ref }}" == "refs/tags/*" ]]; then
            TAG_NAME="${{ github.ref }}"
            TAG_NAME=${TAG_NAME#refs/tags/}
          else
            TAG_NAME="${{ github.event.inputs.tag_name }}"
          fi
          
          echo "Getting release information for tag: $TAG_NAME"
          
          # Get all releases and filter by tag (to include draft releases)
          ALL_RELEASES=$(curl -s -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100")
          
          # Filter for the specific tag
          RELEASE_INFO=$(echo "$ALL_RELEASES" | jq -r --arg TAG "$TAG_NAME" '.[] | select(.tag_name == $TAG) | .')
          
          # Check if we got valid release info
          if echo "$RELEASE_INFO" | jq -e .id &>/dev/null; then
            echo "Successfully retrieved release information"
          else
            echo "Error: Failed to retrieve release information for tag $TAG_NAME"
            echo "Response: $ALL_RELEASES"
            exit 1
          fi
          
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          DRAFT=$(echo "$RELEASE_INFO" | jq -r '.draft')
          TAG_NAME=$(echo "$RELEASE_INFO" | jq -r '.tag_name')
          RELEASE_NAME=$(echo "$RELEASE_INFO" | jq -r '.name')
          RELEASE_BODY=$(echo "$RELEASE_INFO" | jq -r '.body')
          
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          echo "draft=$DRAFT" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "release_body=$RELEASE_BODY" >> $GITHUB_OUTPUT
          
          echo "Release ID: $RELEASE_ID"
          echo "Draft: $DRAFT"
          echo "Tag: $TAG_NAME"
          echo "Release Name: $RELEASE_NAME"
          echo "Release Body: $RELEASE_BODY"
            jq -r '.[] | "- \(.name) (\(.size) bytes)"'
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Copy assets to public repository
        run: |
          # Extract tag name from github.ref or use input tag_name
          if [[ "${{ github.ref }}" == "refs/tags/*" ]]; then
            TAG_NAME="${{ github.ref }}"
            TAG_NAME=${TAG_NAME#refs/tags/}
          else
            TAG_NAME="${{ github.event.inputs.tag_name }}"
          fi
          
          # Get list of assets from source release
          ASSETS_URL="https://api.github.com/repos/${{ github.repository }}/releases/${{ steps.get_release.outputs.release_id }}/assets"
          echo "Fetching assets from: $ASSETS_URL"
          ASSET_LIST=$(curl -s -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" "$ASSETS_URL")
          
          # Check if we got valid asset list
          if echo "$ASSET_LIST" | jq -e . &>/dev/null; then
            echo "Successfully retrieved asset list"
          else
            echo "Error: Failed to retrieve asset list"
            echo "Response: $ASSET_LIST"
            exit 1
          fi
          
          # Determine target tag
          TARGET_TAG="$TAG_NAME"
          
          echo "Target tag for public repository: $TARGET_TAG"
          
          # Create release in public repository if it doesn't exist
          PUBLIC_REPO="AkshayAnuOnline/quikballot"
          
          # Check if release already exists
          echo "Checking if release $TARGET_TAG exists in $PUBLIC_REPO"
          RELEASE_EXISTS=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
            "https://api.github.com/repos/$PUBLIC_REPO/releases/tags/$TARGET_TAG")
          
          echo "Release exists check returned HTTP status: $RELEASE_EXISTS"
          
          if [ "$RELEASE_EXISTS" = "404" ]; then
            echo "Creating new release $TARGET_TAG in $PUBLIC_REPO"
            # Create new release
            RELEASE_DATA=$(jq -n \
              --arg tag "$TARGET_TAG" \
              --arg name "${{ steps.get_release.outputs.release_name }}" \
              --arg body "${{ steps.get_release.outputs.release_body }}" \
              '{tag_name: $tag, name: $name, body: $body, draft: false, prerelease: false}')
            
            RELEASE_RESPONSE=$(curl -s -X POST \
              -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "$RELEASE_DATA" \
              "https://api.github.com/repos/$PUBLIC_REPO/releases")
            
            # Check if release creation was successful
            if echo "$RELEASE_RESPONSE" | jq -e .id &>/dev/null; then
              echo "Successfully created release"
            else
              echo "Error: Failed to create release"
              echo "Response: $RELEASE_RESPONSE"
              exit 1
            fi
            
            PUBLIC_RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
            echo "Created release with ID: $PUBLIC_RELEASE_ID"
          else
            echo "Release $TARGET_TAG already exists, getting release ID"
            # Get existing release ID
            PUBLIC_RELEASE_INFO=$(curl -s -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
              "https://api.github.com/repos/$PUBLIC_REPO/releases/tags/$TARGET_TAG")
            
            # Check if we got valid release info
            if echo "$PUBLIC_RELEASE_INFO" | jq -e .id &>/dev/null; then
              echo "Successfully retrieved existing release information"
            else
              echo "Error: Failed to retrieve existing release information"
              echo "Response: $PUBLIC_RELEASE_INFO"
              exit 1
            fi
            
            PUBLIC_RELEASE_ID=$(echo "$PUBLIC_RELEASE_INFO" | jq -r '.id')
            echo "Existing release ID: $PUBLIC_RELEASE_ID"
          fi
          
          # Copy each asset by downloading first and then uploading
          echo "Copying assets to public repository release $PUBLIC_RELEASE_ID"
          # Create temporary directory for assets
          TEMP_DIR="$(mktemp -d)"
          
          # Counter for copied assets
          COPIED_ASSETS=0
          
          # Process each asset
          echo "$ASSET_LIST" | jq -c '.[]' | while IFS= read -r asset; do
            ASSET_NAME=$(echo "$asset" | jq -r '.name')
            ASSET_URL=$(echo "$asset" | jq -r '.url')
            ASSET_SIZE=$(echo "$asset" | jq -r '.size')
            
            # Only copy installer files (skip blockmap, yml, and other non-installer files)
            if [[ $ASSET_NAME =~ \.(dmg|exe|msi|AppImage|deb)$ ]]; then
              echo "Copying installer $ASSET_NAME ($ASSET_SIZE bytes) to public repository"
              
              # Download asset to temporary file
              TEMP_FILE="$TEMP_DIR/$ASSET_NAME"
              curl -s -L -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
                -H "Accept: application/octet-stream" \
                "$ASSET_URL" -o "$TEMP_FILE"
              
              # Check if download was successful
              if [ -f "$TEMP_FILE" ]; then
                # Upload asset to public repository
                UPLOAD_RESPONSE=$(curl -s -X POST \
                  -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
                  -H "Content-Type: application/octet-stream" \
                  --data-binary "@$TEMP_FILE" \
                  "https://uploads.github.com/repos/$PUBLIC_REPO/releases/$PUBLIC_RELEASE_ID/assets?name=$ASSET_NAME")
                
                # Check if upload was successful
                if echo "$UPLOAD_RESPONSE" | jq -e .id &>/dev/null; then
                  echo "Successfully uploaded $ASSET_NAME"
                  COPIED_ASSETS=$((COPIED_ASSETS + 1))
                else
                  echo "Error uploading $ASSET_NAME: $UPLOAD_RESPONSE"
                fi
              else
                echo "Error downloading $ASSET_NAME"
              fi
              
              # Clean up temporary file
              if [ -f "$TEMP_FILE" ]; then rm "$TEMP_FILE"; fi
            else
              echo "Skipping non-installer file: $ASSET_NAME"
            fi
          done
          
          echo "Finished copying assets. Total installer files copied: $COPIED_ASSETS"
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
